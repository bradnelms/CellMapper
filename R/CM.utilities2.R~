CM.search.sub <-
function(Data, QGs = NULL, CGs = NULL, QDW = TRUE, alpha = 0.5, verbose = TRUE) {
	w <- Data$d^alpha
	if (QDW) {
		if (length(QGs) > 1) {
			w2 <- sweep(sweep(Data$B[,QGs], 1, rowMeans(Data$B), '-'), 1, apply(Data$B, 1, sd), '/')
			w2 <- rowMeans(tanh(w2))
		} else if (length(QGs) == 1) {
			w2 <- (Data$B[,QGs] - rowMeans(Data$B))/apply(Data$B, 1, sd)
			w2 <- tanh(w2)
		}
		w <- abs(w2)*w
	}


	if ((length(QGs) + length(CGs)) > 1) {
		cov.mat <- t(sweep(Data$B[, c(QGs, CGs)], 1, w^2, '*')) %*% Data$B
	} else {
		cov.mat <- t(Data$B[, QGs]*w^2) %*% Data$B
	}

	diags <- sqrt(colSums((Data$B*w)^2))
	cor.mat <- cov.mat/diags[c(QGs, CGs)]
	cor.mat <- sweep(cor.mat, 2, diags, '/')

	colnames(cor.mat) <- colnames(Data$B)
	rownames(cor.mat) <- colnames(Data$B)[c(QGs, CGs)]

	if (!is.null(CGs)) { # Adjust for positive partial correlation with 'control.genes'
		cor.mat <- adjust.pcor(cor.mat, QGs, CGs, verbose)
	}

	if (length(QGs) > 1) {
		cor.vec <- colMeans(atanh(cor.mat[1:length(QGs),-c(QGs, CGs)]))
	} else if (!is.null(dim(cor.mat))) {
		cor.vec <- atanh(cor.mat[1,-c(QGs, CGs)])
	} else {
		cor.vec <- atanh(cor.mat[-c(QGs, CGs)])
	}

	S <- (cor.vec - median(cor.vec, na.rm = TRUE)) / mad(cor.vec, na.rm = TRUE)

	probs <- pnorm(S, lower.tail = FALSE, log.p = TRUE)
	probs <- probs[order(probs)]

	return(probs)
}

adjust.pcor <-
function(cor.mat, QGs, CGs, verbose = TRUE) {
	if (length(QGs) > 1) {
		CG2 <- which(rownames(cor.mat) %in% names(which(colMeans(cor.mat[1:length(QGs),CGs] > 0)==1)))
	} else {
		CG2 <- which(rownames(cor.mat) %in% names(which(cor.mat[1,CGs] > 0)))
	}  # Only consider 'control genes' that are positively correlated with all 'query genes'

	cor.mat <- cor.mat[c(1:length(QGs), CG2),]

	if (length(CG2) > 0) {
		if (verbose) { message("     Adusting for partial correlation with gene(s): '", paste(rownames(cor.mat)[-c(1:length(QGs))], collapse = "', '"), "'\n") }
		if (length(QGs) > 1) {
			keep <- colMeans(sign(cor.mat[1:length(QGs),])) == 1
		} else {
			keep <- cor.mat[1,] > 0
		} # Only calculate partial correlation for genes that are positively correlated with all 'query genes'

		if (length(CG2) > 1) {
			keep <- which(keep & apply(cor.mat[CG2,] > 0, 2, any))

			Positive.controls <- apply(cor.mat[,keep] > 0, 2, which)
			patterns <- unique(Positive.controls)

			zz <- match(rownames(cor.mat), colnames(cor.mat))

			for (i in 1:length(patterns)) {
				mtch = unique(c(keep[Positive.controls %in% patterns[i]], zz[patterns[[i]]]))
				cor.mat[patterns[[i]],mtch] <- adjust.pcor.sub(cor.mat[patterns[[i]],mtch], QGs)
			}
		} else {
			keep <- keep & (cor.mat[CG2,] > 0)
			cor.mat[,keep] <- adjust.pcor.sub(cor.mat[,keep], QGs)
		}

		unique(t(sign(cor.mat[,Positive.cors])))
		apply(Positive.controls == -1, 1, which)


		cor.mat.rd <- cor.mat
		for (z in dim(cor.mat.rd)[1]:(length(QGs)+1)) {
			p.zy <- cor.mat.rd[z,]
			for (x in (1:(z-1))) {
				p.xz <- cor.mat.rd[x, rownames(cor.mat)[z]]
				denom <- (1 - p.xz^2)*(1 - p.zy^2)
				denom[denom < 10^-12] <- NA
				partial <- (cor.mat.rd[x,] - p.xz*p.zy)/sqrt(denom)
				cor.mat.rd[x,][which((Positive.cors + sign(cor.mat[z,])) == 2)] <- partial[which((Positive.cors + sign(cor.mat[z,])) == 2)]
			}
		}
		cor.mat <- sweep(cor.mat.rd, 1, diag(cor.mat.rd[,rownames(cor.mat.rd)]), '/')
	}
	return(cor.mat)
}

adjust.pcor.sub <-
function(cor.mat, QGs) {
	cor.mat.rd <- cor.mat
	for (z in dim(cor.mat.rd)[1]:(length(QGs)+1)) {
		p.zy <- cor.mat.rd[z,]
		for (x in (1:(z-1))) {
			p.xz <- cor.mat.rd[x, rownames(cor.mat)[z]]
			denom <- (1 - p.xz^2)*(1 - p.zy^2)
			denom[denom < 10^-12] <- NA
			cor.mat.rd[x,] <- (cor.mat.rd[x,] - p.xz*p.zy)/sqrt(denom)
		}
	}
	cor.mat <- sweep(cor.mat.rd, 1, diag(cor.mat.rd[,rownames(cor.mat.rd)]), '/')
	return(cor.mat)
}

CM.poolResults <-
function(CM.output) {
	CM.output <- CM.output[!sapply(CM.output, is.null)]

	if (length(CM.output) == 1) {
		out <- CM.output[[1]]
	} else {

		genes <- unique(unlist(lapply(1:length(CM.output), function(i) { names(CM.output[[i]]) })))

		p.vals <- matrix(nrow = length(genes), ncol = length(CM.output))
		rownames(p.vals) <- genes
	
		for (i in 1:length(CM.output)) {
			p.vals[,i] <- CM.output[[i]][genes]
		}

		out <- apply(p.vals, 1, combine.stouffer)
		out <- out[order(out)]
	}

	return(out)
}

combine.stouffer <-
function(p.vals) {
	p.vals <- p.vals[!is.na(p.vals)]
	if (length(p.vals) > 0) {
		p.stouffer <- pnorm(sum(qnorm(p.vals, log.p = TRUE))/sqrt(length(p.vals)), log.p = TRUE)
		return(p.stouffer)
	} else { return(NA) }
}
